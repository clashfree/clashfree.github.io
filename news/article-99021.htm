<!doctype html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
    	<!-- Required meta tags -->
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<link rel="canonical" href="https://clashfree.github.io/news/article-99021.htm" />
	<link rel="icon" href="/assets/website/img/clashfree/favicon.ico" type="image/x-icon"/>
	<title>Netty集成ProtoBuf开发私有协议</title>
		<meta name="description" content="私有协议 广义上区分，通信协议可以分为公有协议和私有协议。由于私有协议的灵活性，它往往会在某个公司或者组织内部使用，按需定制，也因为如此，升级起来会非常方便，灵活性好。绝大多数的私有协议传输层都基于T" />
	
    <meta name="author" content="ClashFree节点免费订阅站">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://clashfree.github.io/news/article-99021.htm" />
    <meta property="og:site_name" content="ClashFree节点免费订阅站" />
    <meta property="og:title" content="Netty集成ProtoBuf开发私有协议" />
    <meta property="og:image" content="https://clashfree.github.io/uploads/20240303/5aba4d49ecfb976fc7257d59ee9aa0d5.webp" />
        <meta property="og:release_date" content="2025-04-19T08:56:13" />
    <meta property="og:updated_time" content="2025-04-19T08:56:13" />
        <meta property="og:description" content="私有协议 广义上区分，通信协议可以分为公有协议和私有协议。由于私有协议的灵活性，它往往会在某个公司或者组织内部使用，按需定制，也因为如此，升级起来会非常方便，灵活性好。绝大多数的私有协议传输层都基于T" />
        
    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Netty集成ProtoBuf开发私有协议">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    
	<link rel="stylesheet" href="/assets/website/css/clashfree/style-starter.css">
	<link href="https://fonts.googleapis.com/css?family=Josefin+Slab:400,700,700i&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Poppins:400,700&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet">
	<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FVS49PB05G"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FVS49PB05G');
</script>
	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body id="home" data-page="detail">
    <section class=" w3l-header-4 header-sticky">
    <header class="absolute-top">
        <div class="container">
            <nav class="navbar navbar-expand-lg navbar-light">
                                <a class="navbar-brand" href="/">
                        Clash Free                    </a>
                                <button class="navbar-toggler bg-gradient collapsed" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="fa icon-expand fa-bars"></span>
                    <span class="fa icon-close fa-times"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav mx-auto">
                                                <li class="nav-item">
                            <a class="nav-link" href="/">首页</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/free-nodes/">免费节点</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/paid-subscribe/">推荐机场</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/client.htm">客户端</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/news/">新闻资讯</a>
                        </li>
                                            </ul>
                </div>
        </div>
        </nav>
        </div>
    </header>
</section>
<script src="/assets/website/js/frontend/clashfree/jquery-3.5.1.min.js"></script> <!-- Common jquery plugin -->
<!--bootstrap working-->
<script src="/assets/website/js/frontend/clashfree/bootstrap.min.js"></script>
<!-- //bootstrap working-->
<!-- disable body scroll which navbar is in active -->
<script>
$(function() {
    $('.navbar-toggler').click(function() {
        $('body').toggleClass('noscroll');
    })
});
</script>
    <!-- breadcrumbs -->
    <section class="w3l-inner-banner-main">
        <div class="about-inner about ">
            <div class="container">
                <div class="main-titles-head text-center">
                    <h1 class="header-name" style="word-break: break-all;">
                        Netty集成ProtoBuf开发私有协议                    </h1>
                    
                </div>
            </div>
        </div>
        <div class="breadcrumbs-sub">
            <div class="container">
                <ul class="breadcrumbs-custom-path">
                    <li class="right-side propClone"><a href="/" class="">首页 <span class="fa fa-angle-right" aria-hidden="true"></span></a>
                        <p>
                    </li>
                    <li class="right-side propClone"><a href="/news/" class="">新闻资讯 <span class="fa fa-angle-right" aria-hidden="true"></span></a>
                        <p>
                    </li>
                    <li class="active ">正文</li>
                </ul>
            </div>
        </div>
        </div>
    </section>
    <!-- breadcrumbs //-->
    <section class="w3l-content-with-photo-4" id="about">
        <div class="content-with-photo4-block ">
            <div class="container">
                <div class="row">
                    <div class="col-md-9">
                                        <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<div id="content_views" class="markdown_views prism-atom-one-dark"> <blockquote> </h1> </blockquote> <h2><a id="_2" rel="nofollow"></a>私有协议</h2> <p>广义上区分，通信协议可以分为公有协议和私有协议。由于私有协议的灵活性，它往往会在某个公司或者组织内部使用，按需定制，也因为如此，升级起来会非常方便，灵活性好。绝大多数的私有协议传输层都基于TCP/IP，所以利用Netty的NIO TCP协议栈可以非常方便地进行私有协议的定制和开发。</p> <h2><a id="_6" rel="nofollow"></a>通信模型</h2> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220602/dbb21fe6c427fd17cfe8d23202c19724.jpg" alt="Netty集成ProtoBuf开发私有协议"></p> <p>(1) Netty协议栈客户端发送握手请求消息，携带节点ID等有效身份认证信息;<br /> (2) Netty 协议栈服务端对握手请求消息进行合法性校验，包括节点ID有效性校验、节点重复登录校验和IP地址合法性校验，校验通过后，返回登录成功的握手应答消息:<br /> (3)链路建立成功之后，客户端发送业务消息;<br /> (4)链路成功之后，服务端发送心跳消息;<br /> (5)链路建立成功之后，客户端发送心跳消息;<br /> (6)链路建立成功之后，服务端发送业务消息;<br /> (7)服务端退出时，服务端关闭连接，客户端感知对方关闭连接后，被动关闭客户端连接。</p> <h2><a id="ProtoBuf_18" rel="nofollow"></a>ProtoBuf数据格式</h2> <pre><code>syntax = "proto3"; option java_package = "com.fy.protobuf"; option java_outer_classname="CustomMessageData";  message MessageData{     int64 length = 1;     Content content = 2;     enum DataType {         REQ_LOGIN = 0;  //上线登录验证环节 等基础信息上报         RSP_LOGIN = 1;  //返回上线登录状态与基础信息         PING = 2;  //心跳         PONG = 3;  //心跳         REQ_ACT = 4;  //动作请求         RSP_ACT = 5;  //动作响应         REQ_CMD = 6;  //指令请求         RSP_CMD = 7;  //指令响应         REQ_LOG = 8 ;//日志请求         RSP_LOG = 9;  //日志响应     }     DataType order = 3;     message Content{         int64 contentLength = 1;         string data = 2;     } }</code></pre> <h2><a id="_48" rel="nofollow"></a>开发步骤</h2> <p>tip????下列步骤有点吃力的小伙伴可以看看之前的文章：https://blog.csdn.net/kunfeisang5551/article/details/107957256</p> <p>1、在D盘protobuf路径下执行命令：protoc.exe --java_out=D:\protobuf CustomMsg.proto</p> <p>2、将生成的文件拷贝到项目中</p> <h3><a id="Coding_56" rel="nofollow"></a>开始Coding~</h3> <p>1、新建maven项目，引入依赖</p> <pre><code>&lt;dependency&gt;     &lt;groupId&gt;io.netty&lt;/groupId&gt;     &lt;artifactId&gt;netty-all&lt;/artifactId&gt;     &lt;version&gt;4.1.51.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;     &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;     &lt;version&gt;3.11.0&lt;/version&gt; &lt;/dependency&gt;</code></pre> <p>2、创建服务端启动代码</p> <pre><code>public class CustomServer {     public void bind(int port) {         EventLoopGroup bossGroup = new NioEventLoopGroup();         EventLoopGroup workGroup = new NioEventLoopGroup();         try {             ServerBootstrap bootstrap = new ServerBootstrap();             bootstrap                     .group(bossGroup, workGroup)                     .channel(NioServerSocketChannel.class)                     .handler(new LoggingHandler(LogLevel.INFO))                     .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {                         @Override                         protected void initChannel(SocketChannel socketChannel) throws Exception {                             socketChannel.pipeline()                                     //消息头定长                                     .addLast(new ProtobufVarint32FrameDecoder())                                     //解码指定的消息类型                                     .addLast(new ProtobufDecoder(CustomMessageData.MessageData.getDefaultInstance()))                                     //消息头设置长度                                     .addLast(new ProtobufVarint32LengthFieldPrepender())                                     //解码                                     .addLast(new ProtobufEncoder())                                     //心跳检测，超过设置的时间将会抛出异常ReadTimeoutException                                     .addLast(new ReadTimeoutHandler(8))                                     //消息处理                                     .addLast(new CustomServerHandler())                                     //心跳响应                                     .addLast(new CustomServerHeartBeatHandler());                         }                     });             // 绑定端口同步等待启动成功             ChannelFuture sync = bootstrap.bind(port).sync();              // 等待服务监听端口关闭             sync.channel().closeFuture().sync();         } catch (Exception e) {             e.printStackTrace();         } finally {             bossGroup.shutdownGracefully();             workGroup.shutdownGracefully();         }     } }</code></pre> <p>3、创建服务端消息处理代码</p> <pre><code>public class CustomServerHandler extends ChannelInboundHandlerAdapter {      private String[] whiteIPv4List = {"127.0.0.1", "192.168.1.188"};     public static ConcurrentHashMap nodeCheck = new ConcurrentHashMap();      @Override     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {         CustomMessageData.MessageData messageData = (CustomMessageData.MessageData) msg;         if (messageData.getOrder() == CustomMessageData.MessageData.DataType.UNRECOGNIZED) {             // 无法识别的消息类型             ctx.close();         }          if (messageData.getOrder() == CustomMessageData.MessageData.DataType.REQ_LOGIN) {             // 检查重复登录             String nodeIndex = ctx.channel().remoteAddress().toString();             if (nodeCheck.contains(nodeIndex)) {                 // 重复登录                 ctx.writeAndFlush(builderResp(false));                 return;             } else {                 InetSocketAddress socketAddress = (InetSocketAddress) ctx.channel().remoteAddress();                 String ip = socketAddress.getAddress().getHostAddress();                 boolean isOk = false;                 // 检查白名单                 for (String s : whiteIPv4List) {                     if (s.equals(ip)) {                         isOk = true;                         break;                     }                 }                 // 成功响应                 CustomMessageData.MessageData responseData = isOk ? builderResp(true) : builderResp(false);                 if (isOk) {                     nodeCheck.put(nodeIndex, true);                 }                 ctx.writeAndFlush(responseData);             }         } else {             //心跳消息处理             ctx.fireChannelRead(msg);         }     }      @Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {         nodeCheck.remove(ctx.channel().remoteAddress().toString());         if (ctx.channel().isActive()) {             ctx.close();         }     }      public CustomMessageData.MessageData builderResp(boolean isOk) {         String r = isOk ? "SUCCESS" : "FAILED";         CustomMessageData.MessageData.Content responseContent = CustomMessageData.MessageData.Content.newBuilder().setData(r).setContentLength(r.length()).build();         CustomMessageData.MessageData responseData = CustomMessageData.MessageData.newBuilder().setOrder(CustomMessageData.MessageData.DataType.RSP_LOGIN).setContent(responseContent).build();         return responseData;     } }</code></pre> <p>4、创建服务端心跳响应代码</p> <pre><code>public class CustomServerHeartBeatHandler extends ChannelInboundHandlerAdapter {      @Override     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {         CustomMessageData.MessageData messageData = (CustomMessageData.MessageData) msg;         if (messageData.getOrder() == CustomMessageData.MessageData.DataType.PING) {             CustomMessageData.MessageData req = CustomMessageData.MessageData.newBuilder()                     .setOrder(CustomMessageData.MessageData.DataType.PONG).build();             System.out.println("Send-Client:PONG,time:" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));             ctx.writeAndFlush(req);         } else {             ctx.fireChannelRead(msg);         }     } }</code></pre> <p>5、创建客户端启动代码</p> <pre><code>public class CustomClient {     public void bind(int port) {         EventLoopGroup group = new NioEventLoopGroup();         try {             Bootstrap b = new Bootstrap();             b.group(group)                     .channel(NioSocketChannel.class)                     .handler(new ChannelInitializer&lt;SocketChannel&gt;() {                         @Override                         protected void initChannel(SocketChannel socketChannel) throws Exception {                             socketChannel.pipeline()                                     .addLast(new ProtobufVarint32FrameDecoder())                                     .addLast(new ProtobufDecoder(CustomMessageData.MessageData.getDefaultInstance()))                                     .addLast(new ProtobufVarint32LengthFieldPrepender())                                     .addLast(new ProtobufEncoder())                                     // 消息处理                                     .addLast(new CustomClientHandler())                                     // 心跳响应                                     .addLast(new CustomClientHeartBeatHandler());                         }                     });             ChannelFuture f = b.connect("127.0.0.1", port).sync();              f.channel().closeFuture().sync();         } catch (Exception e) {             e.printStackTrace();         } finally {             // 短线重连 定时5秒             group.execute(() -&gt; {                 try {                     TimeUnit.MILLISECONDS.sleep(5);                     bind(port);                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }); //            group.shutdownGracefully();         }     } }</code></pre> <p>6、创建客户端消息处理代码</p> <p>这里的逻辑主要是通道激活后马上发送业务消息，然后保持心跳</p> <pre><code>public class CustomClientHandler extends ChannelInboundHandlerAdapter {      @Override     public void channelActive(ChannelHandlerContext ctx) throws Exception {         CustomMessageData.MessageData reqData = CustomMessageData                 .MessageData                 .newBuilder()                 .setOrder(CustomMessageData.MessageData.DataType.REQ_LOGIN)                 .build();         ctx.channel().writeAndFlush(reqData);     }      @Override     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {         CustomMessageData.MessageData respData = (CustomMessageData.MessageData) msg;         if (respData.getOrder() == CustomMessageData.MessageData.DataType.RSP_LOGIN) {             // 响应登录请求处理逻辑             boolean equals = respData.getContent().getData().equals("SUCCESS");             if (equals) {                 System.out.println("Receive-Server:LoginSuccess,time:" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));                 System.out.println(respData.toString());                 // 传递下一个handler                 ctx.fireChannelRead(msg);             } else {                 // 登录失败                 if (ctx.channel().isActive()) {                     ctx.close();                 }             }         } else {             // 响应心跳处理逻辑             ctx.fireChannelRead(msg);         }      }      @Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {         super.exceptionCaught(ctx, cause);         if (ctx.channel().isActive()) {             ctx.close();         }     } }</code></pre> <p>7、创建客户端心跳保持代码</p> <pre><code>public class CustomClientHeartBeatHandler extends ChannelInboundHandlerAdapter {      private static ScheduledFuture heartbeatFuture;      @Override     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {         CustomMessageData.MessageData messageData = (CustomMessageData.MessageData) msg;         if (messageData.getOrder() == CustomMessageData.MessageData.DataType.RSP_LOGIN) {             // 登录成功后保持心跳 间隔为5秒             heartbeatFuture = ctx.executor().scheduleAtFixedRate(() -&gt; {                 CustomMessageData.MessageData req = CustomMessageData.MessageData.newBuilder()                         .setOrder(CustomMessageData.MessageData.DataType.PING).build();                 System.out.println("Send-Server:PING,time:" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));                 ctx.writeAndFlush(req);             }, 0, 5, TimeUnit.SECONDS);         } else if (messageData.getOrder() == CustomMessageData.MessageData.DataType.PONG) {             System.out.println("Receive-Server:PONG,time:" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));             System.out.println();         } else {             ctx.fireChannelRead(msg);         }     }      @Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {         // 发生异常就取消心跳保持         if (heartbeatFuture != null) {             heartbeatFuture.cancel(true);             heartbeatFuture = null;         }         ctx.fireExceptionCaught(cause);     } }</code></pre> <p>8、启动服务端</p> <pre><code>public class Server {     public static void main(String[] args) throws Exception {         new CustomServer().bind(8080);     } }</code></pre> <p>9、启动客户端</p> <pre><code>public class Client {     public static void main(String[] args) {         new CustomClient().bind(8080);     } }</code></pre> <h2><a id="_359" rel="nofollow"></a>控制台打印</h2> <p>1、客户端</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220602/a234e7e177863623734f052b39bc3725.jpg" alt="Netty集成ProtoBuf开发私有协议"></p> <pre><code>Receive-Server:LoginSuccess,time:2020-08-12 17:31:47 content {   contentLength: 7   data: "SUCCESS" } order: RSP_LOGIN  Send-Server:PING,time:2020-08-12 17:31:47 Receive-Server:PONG,time:2020-08-12 17:31:47  Send-Server:PING,time:2020-08-12 17:31:52 Receive-Server:PONG,time:2020-08-12 17:31:52  Send-Server:PING,time:2020-08-12 17:31:57 Receive-Server:PONG,time:2020-08-12 17:31:57  Send-Server:PING,time:2020-08-12 17:32:02 Receive-Server:PONG,time:2020-08-12 17:32:02</code></pre> <p>我们可以看到，当客户端发送登录请求后，服务端响应登录成功消息，然后交替打印心跳保持信息，间隔为5秒。</p> <p>2、服务端</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220602/81a1137e78feaa320f7467b4e9e3e679.jpg" alt="Netty集成ProtoBuf开发私有协议"></p> <pre><code>Send-Client:PONG,time:2020-08-12 17:31:47 Send-Client:PONG,time:2020-08-12 17:31:52 Send-Client:PONG,time:2020-08-12 17:31:57 Send-Client:PONG,time:2020-08-12 17:32:02 Send-Client:PONG,time:2020-08-12 17:32:07</code></pre> <p>服务端响应登录请求后交替打印心跳保持信息。</p> <p>3、测试服务端异常</p> <p>我们先停掉服务端，看看客户端有啥反应，客户端日志：</p> <pre><code>Connection refused: no further information</code></pre> <p>客户端5秒打印一次异常信息，说明短线重连逻辑正常</p> <p>我们接着再启动服务端，看看客户端有啥反应</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220602/180499dbf51e4c95119d5b8873166415.jpg" alt="Netty集成ProtoBuf开发私有协议"></p> <pre><code>io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: no further information: /127.0.0.1:8080 Caused by: java.net.ConnectException: Connection refused: no further information 	at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method) 	at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:717) 	at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:330) 	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334) 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:702) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.lang.Thread.run(Thread.java:748) Receive-Server:LoginSuccess,time:2020-08-12 17:44:15 content {   contentLength: 7   data: "SUCCESS" } order: RSP_LOGIN  Send-Server:PING,time:2020-08-12 17:44:15 Receive-Server:PONG,time:2020-08-12 17:44:15  Send-Server:PING,time:2020-08-12 17:44:20 Receive-Server:PONG,time:2020-08-12 17:44:20</code></pre> <p>可以看到由异常转为正常啦~</p> <p>通过测试可以验证是否符合私有协议的约定：</p> <p>(1)客户端是否能够正常发起重连:<br /> (2)重连成功之后，不再重连:<br /> (3)断连期间，心跳定时器停止工作，不再发送心跳请求消息;<br /> (4)服务端重启成功之后，允许客户端重新登录;<br /> (5)服务端重启成功之后，客户端能够重连和握手成功:<br /> (6)重连成功之后，双方的心跳能够正常互发。<br /> (7)性能指标:重连期间，客户端资源得到了正常回收，不会导致句柄等资源泄漏。</p> <p>GitHub服务端地址：https://github.com/GoodBoy2333/netty-server-maven.git</p> <p>GitHub客户端地址：https://github.com/GoodBoy2333/netty-client-maven.git</p> </div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-98325.htm">动物疫站给猫打疫苗收钱吗多少钱啊一针（动物疫站给猫打疫苗收钱吗多少钱啊一针啊）</a></p>
                                        <p>下一个：<a href="/news/article-99022.htm">重庆宠物领养吧百度贴吧（重庆宠物领养中心宠物领养）</a></p>
                                    </div>
                                    </div>
                    <div class="col-md-3">
                        <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/news/article-81504.htm" title="动物医院需要什么手续才能开（动物医院开设条件）">动物医院需要什么手续才能开（动物医院开设条件）</a></li>
                        <li class="py-2"><a href="/news/article-69377.htm" title="Bootstrap Blazor Table 组件智能生成">Bootstrap Blazor Table 组件智能生成</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-29-node-share-links.htm" title="3月29日 | 最新Clash/V2ray/Shadowrocket/SSR高速免费节点地址，最高速度18.3M/S，便宜机场推荐">3月29日 | 最新Clash/V2ray/Shadowrocket/SSR高速免费节点地址，最高速度18.3M/S，便宜机场推荐</a></li>
                        <li class="py-2"><a href="/news/article-71335.htm" title="宠物粮食市场分析报告总结（宠物粮食行业发展前景）">宠物粮食市场分析报告总结（宠物粮食行业发展前景）</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-28-free-v2ray-subscribe.htm" title="3月28日 | 最新SSR/V2ray/Clash/Shadowrocket高速免费节点地址，最高速度19.3M/S，便宜机场推荐">3月28日 | 最新SSR/V2ray/Clash/Shadowrocket高速免费节点地址，最高速度19.3M/S，便宜机场推荐</a></li>
                        <li class="py-2"><a href="/news/article-76020.htm" title="SpringCloudRPC远程调用核心原理：Feign远程调用的执行流程">SpringCloudRPC远程调用核心原理：Feign远程调用的执行流程</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-22-free-node-subscribe.htm" title="3月22日 | 最新Clash/SSR/V2ray/Shadowrocket高速免费节点地址，最高速度20.7M/S，便宜机场推荐">3月22日 | 最新Clash/SSR/V2ray/Shadowrocket高速免费节点地址，最高速度20.7M/S，便宜机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-26-free-clash-subscribe.htm" title="3月26日 | 最新Clash/Shadowrocket/V2ray/SSR高速免费节点地址，最高速度22.3M/S，便宜机场推荐">3月26日 | 最新Clash/Shadowrocket/V2ray/SSR高速免费节点地址，最高速度22.3M/S，便宜机场推荐</a></li>
                        <li class="py-2"><a href="/news/article-70024.htm" title="动物疫苗打到人身上有事吗有影响吗（动物疫苗打到人身上有事吗有影响吗）">动物疫苗打到人身上有事吗有影响吗（动物疫苗打到人身上有事吗有影响吗）</a></li>
                        <li class="py-2"><a href="/news/article-71997.htm" title="动物疫苗的使用方法及注意事项视频教程大全 动物疫苗的使用方法及注意事项视频教程大全图片">动物疫苗的使用方法及注意事项视频教程大全 动物疫苗的使用方法及注意事项视频教程大全图片</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">56</span> <a href="/date/2025-04/" title="2025-04 归档">2025-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">90</span> <a href="/date/2025-03/" title="2025-03 归档">2025-03</a></h4>
            </li>
                    </ul>
    </div>
</div>



                    </div>
                </div>
            
            </div>
        </div>
    </section>
    
        <section class="w3l-footer-29-main w3l-copyright">
        <div class="container">
            <div class="row bottom-copies">
                                    <p>
                                                <a href="/">首页</a> |
                                                <a href="/free-nodes/">免费节点</a> |
                                                <a href="/paid-subscribe/">推荐机场</a> |
                                                <a href="/client.htm">客户端</a> |
                                                <a href="/news/">新闻资讯</a> |
                                                <a href="/about-us.htm">关于我们</a> |
                        <a href="/disclaimer.htm">免责申明</a> |
                        <a href="/privacy.htm">隐私申明</a> |
                        <a href="/sitemap.xml">网站地图</a>
                    </p>
                <p class="col-lg-8 copy-footer-29">
                    ClashFree节点免费订阅站 版权所有
                    <br />
                    Powered by WordPress
                </p>
                <div class="col-lg-4 main-social-footer-29">
                    <a href="#facebook" class="facebook"><span class="fa fa-facebook"></span></a>
                    <a href="#twitter" class="twitter"><span class="fa fa-twitter"></span></a>
                    <a href="#instagram" class="instagram"><span class="fa fa-instagram"></span></a>
                    <a href="#linkedin" class="linkedin"><span class="fa fa-linkedin"></span></a>
                </div>
            </div>
        </div>
    </section>
    <!-- move top -->
    <button onclick="topFunction()" id="movetop" title="Go to top">
        <span class="fa fa-long-arrow-up"></span>
    </button>
    <script>
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function() {
        scrollFunction()
    };

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            document.getElementById("movetop").style.display = "block";
        } else {
            document.getElementById("movetop").style.display = "none";
        }
    }

    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
    </script>
    <!-- /move top -->
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>